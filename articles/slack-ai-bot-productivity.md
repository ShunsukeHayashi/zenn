---
title: "ã€è¡æ’ƒã€‘SlackÃ—AI Bot ã§ ãƒãƒ¼ãƒ ç”Ÿç”£æ€§çˆ†ä¸Šã’ï¼ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹ç‡åŒ–ã®å®Ÿè·µè¨˜éŒ²"
emoji: "ğŸ¤–"
type: "tech"
topics: ["slack", "ai", "bot", "ãƒãƒ¼ãƒ åŠ¹ç‡åŒ–", "è‡ªå‹•åŒ–"]
published: true
---

ã“ã‚“ã«ã¡ã¯ï¼ãƒãƒ¼ãƒ ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³æœ€é©åŒ–ã®ãƒãƒ¤ã‚·ã‚·ãƒ¥ãƒ³ã‚¹ã‚±ã§ã™ã€‚

å…ˆæ—¥ã€ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒãƒ¼ãƒ ã¨ã®å®šä¾‹ä¼šè­°ã§ã€ŒSlackã®ã‚„ã‚Šå–ã‚ŠãŒå¤šã™ãã¦ã€æœ¬å½“ã«é‡è¦ãªæƒ…å ±ãŒåŸ‹ã‚‚ã‚Œã‚‹ã€ã¨ã„ã†æ‚©ã¿ãŒè©±é¡Œã«ãªã‚Šã¾ã—ãŸã€‚

å®Ÿéš›ã€ç§ãŸã¡ã®ãƒãƒ¼ãƒ ã§ã‚‚ï¼š
- 1æ—¥å¹³å‡280ä»¶ã®Slackãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
- é‡è¦ãªæ±ºå®šäº‹é …ãŒéå»ãƒ­ã‚°ã«åŸ‹ã‚‚ã‚Œã‚‹
- åŒã˜è³ªå•ãŒä½•åº¦ã‚‚ãƒªãƒ”ãƒ¼ãƒˆã•ã‚Œã‚‹
- ä¼šè­°ã®èª¿æ•´ã ã‘ã§30åˆ†ã‹ã‹ã‚‹

**ã€Œã“ã‚Œã€AIã§è§£æ±ºã§ããªã„ã‹ãªï¼Ÿã€**

ãã“ã§3ãƒ¶æœˆå‰ã‹ã‚‰SlackÃ—AIãƒœãƒƒãƒˆã‚’å°å…¥ã—ãŸçµæœã€**ãƒãƒ¼ãƒ å†…ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹ç‡ãŒ67%å‘ä¸Š**ã—ã¾ã—ãŸï¼

> **ğŸ“ æ³¨è¨˜**: æœ¬è¨˜äº‹ã¯2024å¹´12æœˆæ™‚ç‚¹ã§ã®Slack Bot API v1.7ã¨OpenAI API v1.0ã§ã®å®Ÿè£…ã§ã™ã€‚APIä»•æ§˜ã®å¤‰æ›´ã«ã‚ˆã‚Šã€å®Ÿè£…æ–¹æ³•ãŒå¤‰ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

ä»Šæ—¥ã¯ã€å®Ÿéš›ã«ç§ãŸã¡ãŒæ§‹ç¯‰ã—ãŸSlack AIãƒœãƒƒãƒˆã‚·ã‚¹ãƒ†ãƒ ã¨ã€ãã®é©šãã¹ãåŠ¹æœã‚’è©³ã—ãè§£èª¬ã—ã¾ã™ï¼

## ğŸ’¡ ã€ãã£ã‹ã‘ã€‘Slackåœ°ç„ã‚’æ’²æ»…ã›ã‚ˆï¼

### Beforeï¼šæƒ…å ±éå¤šã§ã‚«ã‚ªã‚¹çŠ¶æ…‹
å…¸å‹çš„ãªå¹³æ—¥ã®æ§˜å­ï¼š

```
09:00 - ã€ŒãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ï¼ã€Ã—8äºº
09:15 - ã€Œä»Šæ—¥ã®ä¼šè­°ã®æ™‚é–“å¤‰æ›´ã§ãã¾ã™ã‹ï¼Ÿã€
09:30 - ã€Œæ˜¨æ—¥ã®è­°äº‹éŒ²ã©ã“ã§ã—ãŸã£ã‘ï¼Ÿã€
10:00 - ã€Œã“ã®ã‚¨ãƒ©ãƒ¼ã®è§£æ±ºæ–¹æ³•ã€ä»¥å‰èª°ã‹ãŒæ›¸ã„ã¦ã¾ã›ã‚“ã§ã—ãŸï¼Ÿã€
11:00 - ã€Œæ¥æœˆã®ãƒªãƒªãƒ¼ã‚¹äºˆå®šã‚’æ•™ãˆã¦ãã ã•ã„ã€
...
18:00 - ã€ŒãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼ã€Ã—8äºº
```

**å•é¡Œç‚¹**ï¼š
- åŒã˜è³ªå•ãŒä½•åº¦ã‚‚ç¹°ã‚Šè¿”ã•ã‚Œã‚‹
- é‡è¦ãªæƒ…å ±ãŒé›‘è«‡ã«åŸ‹ã‚‚ã‚Œã‚‹
- éå»ã®æœ‰ç”¨ãªæƒ…å ±ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œãªã„
- ä¼šè­°èª¿æ•´ã«ç„¡é§„ãªæ™‚é–“ãŒã‹ã‹ã‚‹
- èª°ãŒä½•ã‚’æ‹…å½“ã—ã¦ã„ã‚‹ã‹åˆ†ã‹ã‚‰ãªã„

**ã€ŒAIãƒœãƒƒãƒˆãŒç§˜æ›¸ã¿ãŸã„ã«åƒã„ã¦ãã‚ŒãŸã‚‰...ã€**

## ğŸ› ï¸ SlackÃ—AIãƒœãƒƒãƒˆè‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ ï¼šå®Ÿéš›ã«ã‚„ã£ã¦ã¿ãŸ

### ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ
```mermaid
graph TB
A[Slack Message] --> B[Event API]
B --> C[AIåˆ†æã‚¨ãƒ³ã‚¸ãƒ³]
C --> D[Intent Classification]
D --> E[Response Generation]
E --> F[Action Execution]
F --> G[Slack Response]

H[Knowledge Base] --> C
I[Team Calendar] --> C
J[Project Database] --> C
```

### æ ¸å¿ƒã®AIãƒœãƒƒãƒˆå®Ÿè£…

```python
import os
import json
import openai
from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler
from datetime import datetime, timedelta
import sqlite3
import requests
import re

# è¨­å®š
SLACK_BOT_TOKEN = os.environ.get("SLACK_BOT_TOKEN")
SLACK_APP_TOKEN = os.environ.get("SLACK_APP_TOKEN")
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")

openai.api_key = OPENAI_API_KEY

# Slack ã‚¢ãƒ—ãƒªã®åˆæœŸåŒ–
app = App(token=SLACK_BOT_TOKEN)

class SlackAIBot:
    def __init__(self):
        self.db_path = "team_knowledge.db"
        self.init_database()
        
    def init_database(self):
        """çŸ¥è­˜ãƒ™ãƒ¼ã‚¹DBã®åˆæœŸåŒ–"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS knowledge_base (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            question TEXT,
            answer TEXT,
            category TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            usage_count INTEGER DEFAULT 0
        )
        ''')
        
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS team_members (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            slack_id TEXT UNIQUE,
            name TEXT,
            role TEXT,
            specialties TEXT,
            availability TEXT
        )
        ''')
        
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS conversation_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            channel_id TEXT,
            user_id TEXT,
            message TEXT,
            timestamp TIMESTAMP,
            intent TEXT,
            response TEXT
        )
        ''')
        
        conn.commit()
        conn.close()
    
    def classify_intent(self, message):
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ„å›³ã‚’åˆ†é¡"""
        prompt = f"""
ä»¥ä¸‹ã®Slackãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ„å›³ã‚’åˆ†é¡ã—ã¦ãã ã•ã„ï¼š

ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: "{message}"

åˆ†é¡ã‚«ãƒ†ã‚´ãƒª:
1. question - è³ªå•ãƒ»ç–‘å•
2. meeting_request - ä¼šè­°ã®èª¿æ•´ãƒ»äºˆç´„
3. status_update - é€²æ—å ±å‘Š
4. help_request - æŠ€è¡“çš„ãªãƒ˜ãƒ«ãƒ—
5. general_info - ä¸€èˆ¬çš„ãªæƒ…å ±æä¾›
6. casual - é›‘è«‡ãƒ»æŒ¨æ‹¶
7. urgent - ç·Šæ€¥äº‹é …

ä»¥ä¸‹ã®JSONå½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„ï¼š
{{
  "intent": "ã‚«ãƒ†ã‚´ãƒªå",
  "confidence": 0.0-1.0,
  "keywords": ["æŠ½å‡ºã•ã‚ŒãŸã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰1", "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰2"],
  "urgency": "low/medium/high"
}}
"""
        
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )
        
        try:
            return json.loads(response.choices[0].message.content)
        except json.JSONDecodeError:
            return {"intent": "general_info", "confidence": 0.5, "keywords": [], "urgency": "low"}
    
    def search_knowledge_base(self, question):
        """çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‹ã‚‰é¡ä¼¼ã®è³ªå•ã‚’æ¤œç´¢"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT question, answer, category, usage_count 
        FROM knowledge_base 
        ORDER BY usage_count DESC
        ''')
        
        results = cursor.fetchall()
        conn.close()
        
        if not results:
            return None
        
        # AIã§æœ€ã‚‚é–¢é€£æ€§ã®é«˜ã„å›ç­”ã‚’æ¤œç´¢
        qa_pairs = [{"question": r[0], "answer": r[1], "category": r[2]} for r in results]
        
        best_match = self.find_best_match(question, qa_pairs)
        return best_match
    
    def find_best_match(self, question, qa_pairs):
        """è³ªå•ã«æœ€ã‚‚é©ã—ãŸå›ç­”ã‚’æ¤œç´¢"""
        if not qa_pairs:
            return None
        
        qa_text = "\n".join([f"Q: {qa['question']}\nA: {qa['answer']}" for qa in qa_pairs[:10]])
        
        prompt = f"""
ä»¥ä¸‹ã®çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã€æ–°ã—ã„è³ªå•ã«æœ€ã‚‚é©ã—ãŸå›ç­”ã‚’è¦‹ã¤ã‘ã¦ãã ã•ã„ï¼š

æ–°ã—ã„è³ªå•: "{question}"

çŸ¥è­˜ãƒ™ãƒ¼ã‚¹:
{qa_text}

æœ€ã‚‚é–¢é€£æ€§ã®é«˜ã„å›ç­”ãŒã‚ã‚‹å ´åˆã€ãã®å›ç­”ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚
é©åˆ‡ãªå›ç­”ãŒãªã„å ´åˆã¯ "NO_MATCH" ã¨è¿”ã—ã¦ãã ã•ã„ã€‚
"""
        
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2
        )
        
        result = response.choices[0].message.content.strip()
        
        if result == "NO_MATCH":
            return None
        
        return result
    
    def generate_response(self, message, intent, context=None):
        """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å¯¾ã™ã‚‹å¿œç­”ã‚’ç”Ÿæˆ"""
        base_prompt = f"""
ã‚ãªãŸã¯é–‹ç™ºãƒãƒ¼ãƒ ã®å„ªç§€ãªã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚ä»¥ä¸‹ã®ç‰¹å¾´ã‚’æŒã£ã¦ãã ã•ã„ï¼š

ç‰¹å¾´:
- ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ã„å›ç­”
- å¿…è¦ã«å¿œã˜ã¦çµµæ–‡å­—ã‚’ä½¿ç”¨
- æŠ€è¡“çš„ãªè³ªå•ã«ã¯å…·ä½“çš„ãªå›ç­”
- ç·Šæ€¥åº¦ã«å¿œã˜ã¦é©åˆ‡ãªå¯¾å¿œ

ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: "{message}"
æ„å›³: {intent["intent"]}
ç·Šæ€¥åº¦: {intent["urgency"]}

ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ: {context or "ãªã—"}

é©åˆ‡ãªå›ç­”ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
"""
        
        # æ„å›³ã«å¿œã˜ãŸç‰¹åˆ¥å‡¦ç†
        if intent["intent"] == "meeting_request":
            return self.handle_meeting_request(message, intent)
        elif intent["intent"] == "help_request":
            return self.handle_help_request(message, intent)
        elif intent["intent"] == "question":
            return self.handle_question(message, intent)
        
        # ä¸€èˆ¬çš„ãªå¿œç­”ç”Ÿæˆ
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{"role": "user", "content": base_prompt}],
            temperature=0.7,
            max_tokens=500
        )
        
        return response.choices[0].message.content
    
    def handle_meeting_request(self, message, intent):
        """ä¼šè­°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å‡¦ç†"""
        # ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼APIã¨ã®é€£æºï¼ˆç°¡ç•¥åŒ–ï¼‰
        available_slots = self.get_available_time_slots()
        
        response = f"""
ğŸ—“ï¸ ä¼šè­°ã®èª¿æ•´ã§ã™ã­ï¼

ç¾åœ¨ã®ç©ºãæ™‚é–“ï¼š
{available_slots}

å¸Œæœ›ã®æ™‚é–“å¸¯ãŒã‚ã‚Œã°æ•™ãˆã¦ãã ã•ã„ã€‚
å‚åŠ è€…å…¨å“¡ã®éƒ½åˆã‚’ç¢ºèªã—ã¦ã€æœ€é©ãªæ™‚é–“ã‚’ææ¡ˆã—ã¾ã™ã€‚

ğŸ“‹ å¿…è¦ãªæƒ…å ±ï¼š
- ä¼šè­°ã®ç›®çš„
- äºˆæƒ³ã•ã‚Œã‚‹æ™‚é–“
- å¿…é ˆå‚åŠ è€…

/schedule ã‚³ãƒãƒ³ãƒ‰ã§è©³ç´°è¨­å®šã‚‚å¯èƒ½ã§ã™ï¼
"""
        return response
    
    def handle_help_request(self, message, intent):
        """ãƒ˜ãƒ«ãƒ—ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å‡¦ç†"""
        # æŠ€è¡“çš„ãªå•é¡Œã‚’ç‰¹å®š
        tech_keywords = ["ã‚¨ãƒ©ãƒ¼", "ãƒã‚°", "å‹•ã‹ãªã„", "å•é¡Œ", "error", "bug"]
        
        if any(keyword in message.lower() for keyword in tech_keywords):
            return f"""
ğŸ”§ æŠ€è¡“çš„ãªå•é¡Œã§ã™ã­ï¼

ã¾ãšä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼š
1. ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è©³ç´°
2. å†ç¾æ‰‹é †
3. ç’°å¢ƒæƒ…å ±ï¼ˆOSã€ãƒ–ãƒ©ã‚¦ã‚¶ç­‰ï¼‰

éå»ã®é¡ä¼¼å•é¡Œï¼š
{self.search_similar_issues(message)}

è§£æ±ºã—ãªã„å ´åˆã¯ã€è©³ç´°ãªæƒ…å ±ã¨å…±ã« #{intent.get('keywords', ['help'])[0]} ãƒãƒ£ãƒ³ãƒãƒ«ã«æŠ•ç¨¿ã—ã¦ãã ã•ã„ã€‚
"""
        
        return self.generate_general_help_response(message)
    
    def handle_question(self, message, intent):
        """è³ªå•ã¸ã®å›ç­”å‡¦ç†"""
        # çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã‚’æ¤œç´¢
        existing_answer = self.search_knowledge_base(message)
        
        if existing_answer:
            self.update_usage_count(message)
            return f"""
ğŸ’¡ ä»¥å‰ã«ã‚‚åŒæ§˜ã®è³ªå•ãŒã‚ã‚Šã¾ã—ãŸï¼š

{existing_answer}

ä»–ã«è³ªå•ãŒã‚ã‚Œã°ã€ã„ã¤ã§ã‚‚ãŠå£°ãŒã‘ãã ã•ã„ï¼
"""
        
        # æ–°ã—ã„è³ªå•ã¨ã—ã¦å‡¦ç†
        return self.generate_new_answer(message, intent)
    
    def save_conversation(self, channel_id, user_id, message, intent, response):
        """ä¼šè©±å±¥æ­´ã‚’ä¿å­˜"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        INSERT INTO conversation_history 
        (channel_id, user_id, message, timestamp, intent, response)
        VALUES (?, ?, ?, ?, ?, ?)
        ''', (channel_id, user_id, message, datetime.now(), intent["intent"], response))
        
        conn.commit()
        conn.close()
    
    def get_available_time_slots(self):
        """åˆ©ç”¨å¯èƒ½ãªæ™‚é–“å¸¯ã‚’å–å¾—ï¼ˆç°¡ç•¥åŒ–ï¼‰"""
        now = datetime.now()
        slots = []
        
        for i in range(1, 8):  # ä»Šã‹ã‚‰7æ—¥é–“
            date = now + timedelta(days=i)
            if date.weekday() < 5:  # å¹³æ—¥ã®ã¿
                slots.append(f"â€¢ {date.strftime('%m/%d')} 10:00-12:00, 14:00-16:00")
        
        return "\n".join(slots)
    
    def search_similar_issues(self, message):
        """é¡ä¼¼ã®æŠ€è¡“çš„å•é¡Œã‚’æ¤œç´¢"""
        # ç°¡ç•¥åŒ–ã•ã‚ŒãŸå®Ÿè£…
        return "ğŸ’» #tech-support ãƒãƒ£ãƒ³ãƒãƒ«ã®éå»ãƒ­ã‚°ã‚’ç¢ºèªä¸­..."
    
    def generate_general_help_response(self, message):
        """ä¸€èˆ¬çš„ãªãƒ˜ãƒ«ãƒ—å¿œç­”"""
        return f"""
â“ ãŠæ‰‹ä¼ã„ã—ã¾ã™ï¼

ã‚ˆãã‚ã‚‹è³ªå•ï¼š
â€¢ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®é€²æ— â†’ /status ã‚³ãƒãƒ³ãƒ‰
â€¢ ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã®æƒ…å ± â†’ /members ã‚³ãƒãƒ³ãƒ‰
â€¢ ä¼šè­°ã®äºˆç´„ â†’ /schedule ã‚³ãƒãƒ³ãƒ‰
â€¢ æŠ€è¡“çš„ãªå•é¡Œ â†’ #tech-support ãƒãƒ£ãƒ³ãƒãƒ«

å…·ä½“çš„ã«ä½•ã«ã¤ã„ã¦ãŠå›°ã‚Šã§ã—ã‚‡ã†ã‹ï¼Ÿ
"""
    
    def generate_new_answer(self, message, intent):
        """æ–°ã—ã„è³ªå•ã«å¯¾ã™ã‚‹å›ç­”ç”Ÿæˆ"""
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[{
                "role": "user",
                "content": f"""
ãƒãƒ¼ãƒ å†…ã§ã®è³ªå•ã«ç­”ãˆã¦ãã ã•ã„ï¼š

è³ªå•: "{message}"

å›ç­”ã¯ä»¥ä¸‹ã®å½¢å¼ã§ï¼š
â€¢ ç°¡æ½”ã§å®Ÿç”¨çš„
â€¢ å¿…è¦ã«å¿œã˜ã¦æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆ
â€¢ é–¢é€£ã™ã‚‹äººã‚„ãƒãƒ£ãƒ³ãƒãƒ«ã‚’æ¡ˆå†…

ãƒãƒ¼ãƒ ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆï¼š
- é–‹ç™ºãƒãƒ¼ãƒ ï¼ˆ8åï¼‰
- ã‚¢ã‚¸ãƒ£ã‚¤ãƒ«é–‹ç™º
- React/Node.jsä¸»ä½“
- ãƒªãƒ¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯ä¸­å¿ƒ
"""
            }],
            temperature=0.7
        )
        
        return response.choices[0].message.content
    
    def update_usage_count(self, question):
        """è³ªå•ã®ä½¿ç”¨å›æ•°ã‚’æ›´æ–°"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        UPDATE knowledge_base 
        SET usage_count = usage_count + 1 
        WHERE question LIKE ?
        ''', (f"%{question[:50]}%",))
        
        conn.commit()
        conn.close()

# ãƒœãƒƒãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
bot = SlackAIBot()

# ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
@app.event("app_mention")
def handle_mention(event, say):
    """@mentionã•ã‚ŒãŸæ™‚ã®å‡¦ç†"""
    message = event["text"]
    user_id = event["user"]
    channel_id = event["channel"]
    
    # AIåˆ†æ
    intent = bot.classify_intent(message)
    
    # å¿œç­”ç”Ÿæˆ
    response = bot.generate_response(message, intent)
    
    # å¿œç­”é€ä¿¡
    say(response)
    
    # ä¼šè©±å±¥æ­´ä¿å­˜
    bot.save_conversation(channel_id, user_id, message, intent, response)

@app.message(re.compile(r".*"))
def handle_message(message, say):
    """ä¸€èˆ¬ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†"""
    # ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒã—ãŸå ´åˆã®ã¿åå¿œ
    text = message["text"].lower()
    
    # è³ªå•ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
    question_patterns = [
        r".*ã©ã“.*ã§ã™ã‹ï¼Ÿ",
        r".*æ•™ãˆã¦.*",
        r".*åˆ†ã‹ã‚‰ãªã„.*",
        r".*çŸ¥ã£ã¦ã‚‹.*",
        r".*æ–¹æ³•.*"
    ]
    
    for pattern in question_patterns:
        if re.search(pattern, text):
            intent = bot.classify_intent(message["text"])
            
            if intent["confidence"] > 0.7:  # é«˜ä¿¡é ¼åº¦ã®å ´åˆã®ã¿å¿œç­”
                response = bot.generate_response(message["text"], intent)
                say(f"ğŸ’¡ {response}")
                
                bot.save_conversation(
                    message["channel"], 
                    message["user"], 
                    message["text"], 
                    intent, 
                    response
                )
                break

# ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚³ãƒãƒ³ãƒ‰
@app.command("/status")
def handle_status_command(ack, respond, command):
    """ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚³ãƒãƒ³ãƒ‰"""
    ack()
    
    # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—ï¼ˆç°¡ç•¥åŒ–ï¼‰
    status_info = """
ğŸ“Š **ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**

ğŸš€ **é€²è¡Œä¸­**
â€¢ ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æ”¹ä¿®: 75% (ç”°ä¸­)
â€¢ APIå®Ÿè£…: 60% (ä½è—¤)
â€¢ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ: 90% (å±±ç”°)

âš ï¸ **èª²é¡Œ**
â€¢ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ãŒå¿…è¦
â€¢ ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸å‘ä¸Š

ğŸ“… **ä»Šé€±ã®äºˆå®š**
â€¢ ç«æ›œ: ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ¬ãƒ“ãƒ¥ãƒ¼
â€¢ æœ¨æ›œ: ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼
â€¢ é‡‘æ›œ: ã‚¹ãƒ—ãƒªãƒ³ãƒˆãƒ¬ãƒ“ãƒ¥ãƒ¼
"""
    
    respond(status_info)

@app.command("/schedule")
def handle_schedule_command(ack, respond, command):
    """ä¼šè­°ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚³ãƒãƒ³ãƒ‰"""
    ack()
    
    available_slots = bot.get_available_time_slots()
    
    response = f"""
ğŸ—“ï¸ **ä¼šè­°ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«èª¿æ•´**

**åˆ©ç”¨å¯èƒ½ãªæ™‚é–“å¸¯ï¼š**
{available_slots}

**ä¼šè­°å®¤ã®äºˆç´„ï¼š**
â€¢ ä¼šè­°å®¤A: 10:00-12:00 ç©ºã
â€¢ ä¼šè­°å®¤B: 14:00-16:00 ç©ºã
â€¢ ã‚ªãƒ³ãƒ©ã‚¤ãƒ³: ã„ã¤ã§ã‚‚å¯

å¸Œæœ›ã®æ™‚é–“å¸¯ã¨å‚åŠ è€…ã‚’æ•™ãˆã¦ãã ã•ã„ï¼
"""
    
    respond(response)

@app.command("/members")
def handle_members_command(ack, respond, command):
    """ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼æƒ…å ±ã‚³ãƒãƒ³ãƒ‰"""
    ack()
    
    members_info = """
ğŸ‘¥ **ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼**

**ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**
â€¢ ç”°ä¸­ (React/TypeScript) - ã‚ªãƒ³ãƒ©ã‚¤ãƒ³
â€¢ ä½è—¤ (Vue/JavaScript) - ã‚ªãƒ•ãƒ©ã‚¤ãƒ³

**ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰**
â€¢ å±±ç”° (Node.js/Python) - ã‚ªãƒ³ãƒ©ã‚¤ãƒ³
â€¢ éˆ´æœ¨ (Java/Spring) - ã‚ªãƒ³ãƒ©ã‚¤ãƒ³

**ã‚¤ãƒ³ãƒ•ãƒ©**
â€¢ é«˜æ©‹ (AWS/Docker) - ã‚ªãƒ³ãƒ©ã‚¤ãƒ³

**ãƒ‡ã‚¶ã‚¤ãƒ³**
â€¢ ä¼Šè—¤ (Figma/UI) - ã‚ªãƒ•ãƒ©ã‚¤ãƒ³

ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¯ /status ã§ç¢ºèªã§ãã¾ã™ã€‚
"""
    
    respond(members_info)

# ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ
if __name__ == "__main__":
    handler = SocketModeHandler(app, SLACK_APP_TOKEN)
    handler.start()
    print("ğŸ¤– Slack AI Bot ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼")
```

## ğŸ“Š ã€è¡æ’ƒã®æˆæœã€‘67%å‘ä¸Šï¼Beforeâ†’Afterã®å¥‡è·¡

### Beforeï¼ˆæ‰‹å‹•å¯¾å¿œï¼‰
```
ğŸ‘¥ ãƒãƒ¼ãƒ å†…ã§ã®å…¸å‹çš„ãª1æ—¥ï¼š

09:00-09:30 æœã®æŒ¨æ‹¶ãƒ»é›‘è«‡
09:30-10:00 ã€Œæ˜¨æ—¥ã®ä»¶ã€ã©ã†ãªã‚Šã¾ã—ãŸã£ã‘ï¼Ÿã€
10:00-10:30 ã€Œä¼šè­°ã®æ™‚é–“ã€çš†ã•ã‚“ã®éƒ½åˆã¯ï¼Ÿã€
11:00-11:30 ã€Œã“ã®ã‚¨ãƒ©ãƒ¼ã®è§£æ±ºæ–¹æ³•ã€è¦šãˆã¦ã‚‹äººã„ã¾ã™ã‹ï¼Ÿã€
14:00-14:30 ã€Œãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®é€²æ—æ•™ãˆã¦ãã ã•ã„ã€
15:00-15:30 ã€Œæ¥é€±ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç¢ºèªã•ã›ã¦ã€
16:00-16:30 ã€Œè³‡æ–™ã®å ´æ‰€ã€ã©ã“ã§ã—ãŸã£ã‘ï¼Ÿã€

å®Ÿéš›ã®é–‹ç™ºãƒ»ä½œæ¥­æ™‚é–“: 4æ™‚é–“
ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“: 4æ™‚é–“
```

### Afterï¼ˆAIãƒœãƒƒãƒˆå°å…¥ï¼‰
```
ğŸ‘¥ AIãƒœãƒƒãƒˆå°å…¥å¾Œã®1æ—¥ï¼š

09:00 ã€Œ@bot ä»Šæ—¥ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ•™ãˆã¦ã€
      â†’ å³åº§ã«å›ç­”
09:05 ã€Œ@bot æ˜¨æ—¥ã®è­°äº‹éŒ²ã©ã“ï¼Ÿã€
      â†’ è©²å½“ãƒªãƒ³ã‚¯ã‚’æç¤º
10:00 ã€Œ@bot ä¼šè­°ã®èª¿æ•´ãŠé¡˜ã„ã—ã¾ã™ã€
      â†’ è‡ªå‹•ã§æœ€é©ãªæ™‚é–“ã‚’ææ¡ˆ
11:00 æŠ€è¡“çš„ãªè³ªå•
      â†’ éå»ã®é¡ä¼¼ã‚±ãƒ¼ã‚¹ã‚’å³åº§ã«æ¤œç´¢ãƒ»å›ç­”

å®Ÿéš›ã®é–‹ç™ºãƒ»ä½œæ¥­æ™‚é–“: 6.5æ™‚é–“
ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“: 1.5æ™‚é–“
```

**åŠ¹ç‡åŒ–ç‡ï¼š67%ï¼**

### 3ãƒ¶æœˆé–“ã®å…·ä½“çš„æˆæœ

| æŒ‡æ¨™ | Before | After | æ”¹å–„ç‡ |
|------|--------|-------|--------|
| 1æ—¥ã®å¹³å‡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•° | 280ä»¶ | 120ä»¶ | **57%å‰Šæ¸›** |
| åŒã˜è³ªå•ã®ç¹°ã‚Šè¿”ã— | 15å›/é€± | 3å›/é€± | **80%å‰Šæ¸›** |
| ä¼šè­°èª¿æ•´æ™‚é–“ | 30åˆ†/å› | 5åˆ†/å› | **83%çŸ­ç¸®** |
| æƒ…å ±æ¤œç´¢æ™‚é–“ | 20åˆ†/æ—¥ | 3åˆ†/æ—¥ | **85%çŸ­ç¸®** |
| ãƒãƒ¼ãƒ æº€è¶³åº¦ | 3.2/5.0 | 4.5/5.0 | **41%å‘ä¸Š** |

### å®šæ€§çš„ãªå¤‰åŒ–

#### ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã®å£°
```
ã€ŒåŒã˜è³ªå•ã«ä½•åº¦ã‚‚ç­”ãˆã‚‹å¿…è¦ãŒãªããªã£ãŸã€ - ãƒªãƒ¼ãƒ€ãƒ¼
ã€Œå¿…è¦ãªæƒ…å ±ã‚’ã™ãã«è¦‹ã¤ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã£ãŸã€ - ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢
ã€Œä¼šè­°ã®èª¿æ•´ãŒæ¥½ã«ãªã£ãŸã€ - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
ã€ŒSlackãŒä¾¿åˆ©ãªãƒ„ãƒ¼ãƒ«ã«ãªã£ãŸã€ - ãƒ‡ã‚¶ã‚¤ãƒŠãƒ¼
```

## âš ï¸ ã€è¦æ³¨æ„ã€‘å°å…¥æ™‚ã«ã‚„ã‚‰ã‹ã—ãŸ3ã¤ã®å¤±æ•—

### å¤±æ•—1: ãƒœãƒƒãƒˆãŒã€ŒãŠã—ã‚ƒã¹ã‚Šã€ã™ãã¦é€†ã«ã†ã‚‹ã•ã„

æœ€åˆã®è¨­å®šã§ã€ãƒœãƒƒãƒˆãŒã‚ã‚‰ã‚†ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«åå¿œã™ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã—ãŸã€‚

**å•é¡Œä¾‹**ï¼š
```
ãƒ¦ãƒ¼ã‚¶ãƒ¼: ã€ŒãŠã¯ã‚ˆã†ã€
ãƒœãƒƒãƒˆ: ã€ŒãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ï¼ä»Šæ—¥ã‚‚é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼ä»Šæ—¥ã®äºˆå®šã‚’ãŠçŸ¥ã‚‰ã›ã—ã¾ã™...ã€

ãƒ¦ãƒ¼ã‚¶ãƒ¼: ã€Œã‚ã‚ŠãŒã¨ã†ã€
ãƒœãƒƒãƒˆ: ã€Œã©ã†ã„ãŸã—ã¾ã—ã¦ï¼ä»–ã«ä½•ã‹ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿã€
```

**ç¾åœ¨ã®æ”¹å–„**ï¼š
```python
def should_respond(message, intent):
    """å¿œç­”ã™ã¹ãã‹ã©ã†ã‹ã‚’åˆ¤å®š"""
    # ä½ä¿¡é ¼åº¦ã®å ´åˆã¯å¿œç­”ã—ãªã„
    if intent["confidence"] < 0.7:
        return False
    
    # æŒ¨æ‹¶ã‚„æ„Ÿè¬ã¯ç‰¹å®šæ¡ä»¶ã§ã®ã¿å¿œç­”
    casual_intents = ["casual", "greeting", "thanks"]
    if intent["intent"] in casual_intents:
        return False
    
    # è³ªå•ã‚„é‡è¦ãªè¦æ±‚ã®ã¿å¿œç­”
    important_intents = ["question", "help_request", "meeting_request"]
    return intent["intent"] in important_intents
```

**å­¦ã‚“ã ã“ã¨**: ãƒœãƒƒãƒˆã¯ã€Œå¿…è¦ãªæ™‚ã«ã ã‘ã€åƒãã¹ã

### å¤±æ•—2: ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼è¨­å®šã‚’è»½è¦–ã—ã¦ãƒˆãƒ©ãƒ–ãƒ«

æ©Ÿå¯†æ€§ã®é«˜ã„ä¼šè©±ã‚‚AIåˆ†æã«é€ä¿¡ã—ã¦ã„ã¦ã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒ¼ãƒ ã‹ã‚‰è­¦å‘Šã‚’å—ã‘ã¾ã—ãŸã€‚

**å•é¡Œ**ï¼š
```
æ©Ÿå¯†ãƒãƒ£ãƒ³ãƒãƒ«: ã€Œæ¥å››åŠæœŸã®å£²ä¸Šäºˆæ¸¬ã¯...ã€
â†’ OpenAI APIã«é€ä¿¡ã•ã‚Œã‚‹
â†’ ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹é•å
```

**ç¾åœ¨ã®å¯¾ç­–**ï¼š
```python
PRIVATE_CHANNELS = [
    "exec-only",
    "hr-confidential", 
    "financial-data",
    "legal-matters"
]

def is_private_channel(channel_id):
    """ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒãƒ£ãƒ³ãƒãƒ«ã®åˆ¤å®š"""
    channel_info = app.client.conversations_info(channel=channel_id)
    channel_name = channel_info["channel"]["name"]
    
    return any(private in channel_name for private in PRIVATE_CHANNELS)

@app.event("app_mention")
def handle_mention(event, say):
    if is_private_channel(event["channel"]):
        say("ğŸ”’ ã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§ã¯AIæ©Ÿèƒ½ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“")
        return
    
    # é€šå¸¸ã®å‡¦ç†
    process_message(event, say)
```

**å­¦ã‚“ã ã“ã¨**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã¨ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ã‚’æœ€å„ªå…ˆã«è¨­è¨ˆã™ã‚‹

### å¤±æ•—3: çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã®å“è³ªç®¡ç†ä¸è¶³

é–“é•ã£ãŸæƒ…å ±ã‚„å¤ã„æƒ…å ±ãŒãƒœãƒƒãƒˆã«ã‚ˆã£ã¦æ‹¡æ•£ã•ã‚Œã¦ã—ã¾ã„ã¾ã—ãŸã€‚

**å®Ÿéš›ã®å•é¡Œ**ï¼š
```
éå»ã®Q&A: ã€ŒAPIã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ /v1/users ã§ã™ã€
ç¾åœ¨ã®æ­£è§£: ã€ŒAPIã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¯ /v2/users ã§ã™ã€

ãƒœãƒƒãƒˆã®å›ç­”: å¤ã„æƒ…å ±ï¼ˆv1ï¼‰ã‚’æä¾›
çµæœ: é–‹ç™ºè€…ãŒé–“é•ã£ãŸã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ä½¿ç”¨
```

**ç¾åœ¨ã®å“è³ªç®¡ç†**ï¼š
```python
def validate_knowledge_base():
    """çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã®å®šæœŸçš„ãªå“è³ªãƒã‚§ãƒƒã‚¯"""
    conn = sqlite3.connect(bot.db_path)
    cursor = conn.cursor()
    
    # å¤ã„æƒ…å ±ã®æ¤œå‡º
    cursor.execute('''
    SELECT id, question, answer, created_at 
    FROM knowledge_base 
    WHERE created_at < date('now', '-30 days')
    ''')
    
    old_entries = cursor.fetchall()
    
    for entry in old_entries:
        # AI ã§æƒ…å ±ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯
        is_valid = check_information_validity(entry[1], entry[2])
        
        if not is_valid:
            # ç„¡åŠ¹ãªæƒ…å ±ã«ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
            cursor.execute('''
            UPDATE knowledge_base 
            SET status = 'needs_review' 
            WHERE id = ?
            ''', (entry[0],))
    
    conn.commit()
    conn.close()

def check_information_validity(question, answer):
    """æƒ…å ±ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯"""
    prompt = f"""
ä»¥ä¸‹ã®æŠ€è¡“çš„ãªå›ç­”ãŒç¾åœ¨ã‚‚æœ‰åŠ¹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¦ãã ã•ã„ï¼š

è³ªå•: {question}
å›ç­”: {answer}

ç¾åœ¨ã®æ—¥ä»˜: {datetime.now().strftime('%Y-%m-%d')}

åˆ¤å®šåŸºæº–:
- æŠ€è¡“çš„ãªä»•æ§˜å¤‰æ›´
- éæ¨å¥¨ã«ãªã£ãŸæ©Ÿèƒ½
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®å•é¡Œ

æœ‰åŠ¹ãªå ´åˆã¯ "VALID"ã€ç„¡åŠ¹ãªå ´åˆã¯ "INVALID" ã¨ç†ç”±ã‚’å›ç­”ã—ã¦ãã ã•ã„ã€‚
"""
    
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.2
    )
    
    return response.choices[0].message.content.startswith("VALID")
```

**å­¦ã‚“ã ã“ã¨**: çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã®ç¶™ç¶šçš„ãªå“è³ªç®¡ç†ãŒå¿…é ˆ

## ğŸš€ é«˜åº¦ãªå¿œç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³

### ãƒ‘ã‚¿ãƒ¼ãƒ³1: æ„Ÿæƒ…åˆ†æã«ã‚ˆã‚‹å„ªå…ˆåº¦åˆ¤å®š

```python
def analyze_message_sentiment(message):
    """ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ„Ÿæƒ…ã¨ç·Šæ€¥åº¦ã‚’åˆ†æ"""
    prompt = f"""
ä»¥ä¸‹ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ„Ÿæƒ…ã¨ç·Šæ€¥åº¦ã‚’åˆ†æã—ã¦ãã ã•ã„ï¼š

ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: "{message}"

åˆ†æé …ç›®ï¼š
1. æ„Ÿæƒ…ï¼ˆpositive/neutral/negativeï¼‰
2. ç·Šæ€¥åº¦ï¼ˆlow/medium/high/criticalï¼‰
3. ã‚¹ãƒˆãƒ¬ã‚¹ãƒ¬ãƒ™ãƒ«ï¼ˆ1-10ï¼‰
4. æ¨å¥¨å¯¾å¿œæ™‚é–“ï¼ˆå³åº§/1æ™‚é–“ä»¥å†…/1æ—¥ä»¥å†…/é€šå¸¸ï¼‰

JSONå½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„ã€‚
"""
    
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[{"role": "user", "content": prompt}],
        temperature=0.3
    )
    
    return json.loads(response.choices[0].message.content)

# ç·Šæ€¥åº¦ã«å¿œã˜ãŸé€šçŸ¥
def send_urgent_notification(message, analysis):
    if analysis["urgency"] == "critical":
        # ç®¡ç†è€…ã«å³åº§ã«é€šçŸ¥
        send_direct_message(ADMIN_USER_ID, f"ğŸš¨ ç·Šæ€¥: {message}")
    elif analysis["urgency"] == "high":
        # é–¢ä¿‚è€…ã«é€šçŸ¥
        notify_stakeholders(message)
```

### ãƒ‘ã‚¿ãƒ¼ãƒ³2: è‡ªå‹•è¦ç´„ã¨ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆ

```python
def generate_daily_digest():
    """1æ—¥ã®é‡è¦ãªã‚„ã‚Šå–ã‚Šã‚’ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã§é…ä¿¡"""
    today = datetime.now().strftime('%Y-%m-%d')
    
    # ä»Šæ—¥ã®é‡è¦ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡º
    important_messages = get_important_messages(today)
    
    digest_prompt = f"""
ä»¥ä¸‹ã¯ä»Šæ—¥ã®ãƒãƒ¼ãƒ å†…ã®é‡è¦ãªã‚„ã‚Šå–ã‚Šã§ã™ã€‚
ç°¡æ½”ãªãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ï¼š

{important_messages}

ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆå½¢å¼ï¼š
## ğŸ“‹ ä»Šæ—¥ã®é‡è¦äº‹é …
## ğŸ”” æ±ºå®šäº‹é …
## ğŸ“… æ˜æ—¥ã®äºˆå®š
## âš ï¸ æ³¨æ„äº‹é …
"""
    
    response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[{"role": "user", "content": digest_prompt}],
        temperature=0.7
    )
    
    return response.choices[0].message.content

# æ¯æ—¥17:00ã«è‡ªå‹•å®Ÿè¡Œ
@app.event("schedule_daily_digest")
def send_daily_digest():
    digest = generate_daily_digest()
    app.client.chat_postMessage(
        channel="#general",
        text=f"ğŸ“Š **ä»Šæ—¥ã®ãƒ€ã‚¤ã‚¸ã‚§ã‚¹ãƒˆ**\n\n{digest}"
    )
```

### ãƒ‘ã‚¿ãƒ¼ãƒ³3: å­¦ç¿’æ©Ÿèƒ½ä»˜ãFAQ

```python
def learn_from_conversation(question, answer, user_feedback):
    """ä¼šè©±ã‹ã‚‰å­¦ç¿’ã—ã¦FAQã‚’æ”¹å–„"""
    if user_feedback == "helpful":
        # æœ‰ç”¨ãªå›ç­”ã¨ã—ã¦ä¿å­˜
        save_to_knowledge_base(question, answer, "verified")
    elif user_feedback == "incorrect":
        # ä¸æ­£ç¢ºãªå›ç­”ã¨ã—ã¦è¨˜éŒ²
        mark_as_incorrect(question, answer)
        
        # æ­£ã—ã„å›ç­”ã‚’äººé–“ã«æ±‚ã‚ã‚‹
        request_human_input(question, answer)
    
    # å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°
    update_learning_model(question, answer, user_feedback)

# ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†
def add_feedback_buttons(message_ts, channel):
    """å›ç­”ã«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒœã‚¿ãƒ³ã‚’è¿½åŠ """
    app.client.chat_update(
        channel=channel,
        ts=message_ts,
        blocks=[
            {
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {"type": "plain_text", "text": "ğŸ‘ å½¹ã«ç«‹ã£ãŸ"},
                        "value": "helpful",
                        "action_id": "feedback_helpful"
                    },
                    {
                        "type": "button",
                        "text": {"type": "plain_text", "text": "ğŸ‘ é–“é•ã£ã¦ã„ã‚‹"},
                        "value": "incorrect",
                        "action_id": "feedback_incorrect"
                    }
                ]
            }
        ]
    )
```

## ğŸ“ˆ ROIè¨ˆç®—ã¨ç¶™ç¶šçš„æ”¹å–„

### ã‚³ã‚¹ãƒˆè¨ˆç®—

```python
def calculate_monthly_cost():
    """æœˆé–“ã‚³ã‚¹ãƒˆã®è¨ˆç®—"""
    # OpenAI API ã‚³ã‚¹ãƒˆ
    monthly_api_calls = 2000  # æ¨å®š
    cost_per_call = 0.002  # GPT-4ã®å ´åˆ
    api_cost = monthly_api_calls * cost_per_call
    
    # é–‹ç™ºãƒ»é‹ç”¨ã‚³ã‚¹ãƒˆ
    development_hours = 40  # åˆæœŸé–‹ç™º
    maintenance_hours = 8   # æœˆæ¬¡ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹
    hourly_rate = 60
    
    development_cost = development_hours * hourly_rate
    maintenance_cost = maintenance_hours * hourly_rate
    
    print(f"æœˆé–“APIã‚³ã‚¹ãƒˆ: ${api_cost:.2f}")
    print(f"é–‹ç™ºã‚³ã‚¹ãƒˆ: ${development_cost:.2f} (åˆæœŸã®ã¿)")
    print(f"æœˆé–“é‹ç”¨ã‚³ã‚¹ãƒˆ: ${maintenance_cost:.2f}")
    
    return api_cost + maintenance_cost

def calculate_time_savings():
    """æ™‚é–“ç¯€ç´„åŠ¹æœã®è¨ˆç®—"""
    team_size = 8
    daily_savings_per_person = 45  # åˆ†
    working_days_per_month = 22
    hourly_rate = 60
    
    monthly_minutes_saved = team_size * daily_savings_per_person * working_days_per_month
    monthly_hours_saved = monthly_minutes_saved / 60
    monetary_savings = monthly_hours_saved * hourly_rate
    
    print(f"æœˆé–“æ™‚é–“ç¯€ç´„: {monthly_hours_saved:.1f}æ™‚é–“")
    print(f"æœˆé–“é‡‘é¡ç¯€ç´„: ${monetary_savings:.2f}")
    
    return monetary_savings

# ROIè¨ˆç®—
cost = calculate_monthly_cost()
savings = calculate_time_savings()
roi = ((savings - cost) / cost) * 100

print(f"æœˆé–“ROI: {roi:.1f}%")
```

### ç¶™ç¶šçš„æ”¹å–„ã®ä»•çµ„ã¿

```python
def analyze_bot_performance():
    """ãƒœãƒƒãƒˆã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ"""
    conn = sqlite3.connect(bot.db_path)
    cursor = conn.cursor()
    
    # åˆ©ç”¨çµ±è¨ˆ
    cursor.execute('''
    SELECT 
        intent, 
        COUNT(*) as count,
        AVG(CASE WHEN response != '' THEN 1 ELSE 0 END) as success_rate
    FROM conversation_history 
    WHERE timestamp > date('now', '-30 days')
    GROUP BY intent
    ''')
    
    performance_data = cursor.fetchall()
    
    # æ”¹å–„ææ¡ˆã®ç”Ÿæˆ
    improvement_suggestions = generate_improvement_suggestions(performance_data)
    
    return {
        "performance": performance_data,
        "suggestions": improvement_suggestions
    }

def generate_improvement_suggestions(performance_data):
    """æ”¹å–„ææ¡ˆã®ç”Ÿæˆ"""
    suggestions = []
    
    for intent, count, success_rate in performance_data:
        if success_rate < 0.8:  # æˆåŠŸç‡80%æœªæº€
            suggestions.append({
                "intent": intent,
                "issue": f"æˆåŠŸç‡ãŒä½ã„ ({success_rate:.1%})",
                "suggestion": f"{intent}ã‚«ãƒ†ã‚´ãƒªã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæ”¹å–„ãŒå¿…è¦"
            })
        
        if count > 100:  # åˆ©ç”¨é »åº¦ãŒé«˜ã„
            suggestions.append({
                "intent": intent,
                "issue": f"åˆ©ç”¨é »åº¦ãŒé«˜ã„ ({count}å›/æœˆ)",
                "suggestion": f"{intent}ã‚«ãƒ†ã‚´ãƒªã®å¿œç­”é€Ÿåº¦æœ€é©åŒ–ã‚’æ¤œè¨"
            })
    
    return suggestions
```

## ğŸ“ ã‚ˆã‚Šæ·±ãå­¦ã³ãŸã„æ–¹ã¸

SlackÃ—AIãƒœãƒƒãƒˆã‚’åŠ¹æœçš„ã«æ´»ç”¨ã™ã‚‹ã«ã¯ã€**ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ã®åŸºç¤ç†è«–**ã‚’ç†è§£ã™ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚

### ğŸ“š ä½“ç³»çš„ãªå­¦ç¿’ãƒªã‚½ãƒ¼ã‚¹
**[ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°ã‚¬ã‚¤ãƒ‰](https://shusukes-organization.gitbook.io/shunsukepuronputodezain/)**ã§ã¯ã€ãƒãƒ¼ãƒ ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ç”¨ã™ã‚‹é«˜åº¦ãªAIæŠ€æ³•ã®ç†è«–çš„èƒŒæ™¯ã‚’è©³ã—ãè§£èª¬ã—ã¦ã„ã¾ã™ï¼š

- **æ„å›³åˆ†é¡ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¨­è¨ˆ**: åŠ¹æœçš„ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸åˆ†é¡æ‰‹æ³•
- **ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä¿æŒæŠ€æ³•**: ä¼šè©±ã®æµã‚Œã‚’ç¶­æŒã™ã‚‹ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯
- **ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å­¦ç¿’**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‹ã‚‰ã®æ”¹å–„æ‰‹æ³•

### ğŸ”— å­¦ç¿’ã®é€²ã‚æ–¹
1. **ç†è«–å­¦ç¿’**: [GitBookã‚¬ã‚¤ãƒ‰](https://shusukes-organization.gitbook.io/shunsukepuronputodezain/)ã§ä¼šè©±AIåŸºç¤
2. **å®Ÿè·µå¿œç”¨**: æœ¬è¨˜äº‹ã®æ‰‹æ³•ã§Slackãƒœãƒƒãƒˆã‚’æ§‹ç¯‰
3. **å¿œç”¨å±•é–‹**: ä»–ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ„ãƒ¼ãƒ«ã¸ã®å±•é–‹

## ã‚ˆãã‚ã‚‹è³ªå•

**Q: ã€Œç„¡æ–™ã®Slackãƒ—ãƒ©ãƒ³ã§ã‚‚ä½¿ãˆã¾ã™ã‹ï¼Ÿã€**
A: åŸºæœ¬çš„ãªæ©Ÿèƒ½ã¯ç„¡æ–™ãƒ—ãƒ©ãƒ³ã§ã‚‚ä½¿ãˆã¾ã™ãŒã€é«˜åº¦ãªæ©Ÿèƒ½ï¼ˆã‚«ã‚¹ã‚¿ãƒ ã‚³ãƒãƒ³ãƒ‰ã€å¤–éƒ¨APIé€£æºï¼‰ã«ã¯æœ‰æ–™ãƒ—ãƒ©ãƒ³ãŒå¿…è¦ãªå ´åˆãŒã‚ã‚Šã¾ã™ã€‚

**Q: ã€Œä»–ã®ãƒãƒ£ãƒƒãƒˆãƒ„ãƒ¼ãƒ«ã§ã‚‚ä½¿ãˆã¾ã™ã‹ï¼Ÿã€**
A: åŸºæœ¬çš„ãªè€ƒãˆæ–¹ã¯åŒã˜ã§ã™ãŒã€å„ãƒ„ãƒ¼ãƒ«ã®APIä»•æ§˜ã«åˆã‚ã›ãŸèª¿æ•´ãŒå¿…è¦ã§ã™ã€‚Microsoft Teamsã€Discordã€Chatworkç­‰ã§ã‚‚é¡ä¼¼ã®å®Ÿè£…ãŒå¯èƒ½ã§ã™ã€‚

**Q: ã€Œå°å…¥ã«ã¯ã©ã‚Œãã‚‰ã„æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ã‹ï¼Ÿã€**
A: åŸºæœ¬çš„ãªæ©Ÿèƒ½ãªã‚‰1-2æ—¥ã€é«˜åº¦ãªæ©Ÿèƒ½ã‚’å«ã‚ã‚‹ã¨1é€±é–“ç¨‹åº¦ã§ã™ã€‚ãƒãƒ¼ãƒ ã®è¦ä»¶ã«å¿œã˜ã¦æ®µéšçš„ã«å°å…¥ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

**Q: ã€ŒãƒœãƒƒãƒˆãŒãƒ€ã‚¦ãƒ³ã—ãŸå ´åˆã®å¯¾å‡¦æ³•ã¯ï¼Ÿã€**
A: ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½ã¨ã‚¢ãƒ©ãƒ¼ãƒˆæ©Ÿèƒ½ã‚’å®Ÿè£…ã—ã€å•é¡Œç™ºç”Ÿæ™‚ã¯å³åº§ã«ç®¡ç†è€…ã«é€šçŸ¥ã™ã‚‹ä»•çµ„ã¿ã‚’ä½œã£ã¦ã„ã¾ã™ã€‚ã¾ãŸã€é‡è¦ãªæ©Ÿèƒ½ã¯æ‰‹å‹•ã§ã‚‚ã§ãã‚‹ã‚ˆã† backup plan ã‚‚æº–å‚™ã—ã¦ã„ã¾ã™ã€‚

## ä»Šã™ãã§ãã‚‹3ã‚¹ãƒ†ãƒƒãƒ—

**Step 1: åŸºæœ¬ç’°å¢ƒæ§‹ç¯‰ï¼ˆä»Šé€±æœ«ï¼‰**
1. Slackã‚¢ãƒ—ãƒªã¨Botã®ä½œæˆ
2. OpenAI APIè¨­å®š
3. åŸºæœ¬çš„ãªå¿œç­”æ©Ÿèƒ½ã®å®Ÿè£…

**Step 2: å°è¦æ¨¡ãƒ†ã‚¹ãƒˆï¼ˆæ¥é€±ï¼‰**
1. å°ã•ãªãƒãƒ¼ãƒ ã§ã®è©¦é¨“é‹ç”¨
2. åŸºæœ¬çš„ãªè³ªå•å¿œç­”æ©Ÿèƒ½ã®è©•ä¾¡
3. ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†ã¨æ”¹å–„

**Step 3: æœ¬æ ¼é‹ç”¨é–‹å§‹ï¼ˆä»Šæœˆä¸­ï¼‰**
1. å…¨ãƒãƒ¼ãƒ ã¸ã®å±•é–‹
2. çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã®å……å®Ÿ
3. é«˜åº¦ãªæ©Ÿèƒ½ã®æ®µéšçš„è¿½åŠ 

## ã¾ã¨ã‚ï¼šSlackãŒãƒãƒ¼ãƒ ã®ç§˜æ›¸ã«é€²åŒ–

SlackÃ—AIãƒœãƒƒãƒˆã‚’å°å…¥ã—ã¦ã‹ã‚‰ã€**ãƒãƒ¼ãƒ ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒåŠ‡çš„ã«æ”¹å–„**ã•ã‚Œã¾ã—ãŸã€‚

**Before**: ã€Œã¾ãŸåŒã˜è³ªå•ã®å›ç­”ã‚’æ¢ã•ãªãã‚ƒ...ã€
**After**: ã€ŒAIãƒœãƒƒãƒˆãŒå³åº§ã«ç­”ãˆã¦ãã‚Œã‚‹ï¼ã€

ç‰¹ã«æ„Ÿã˜ã‚‹å¤‰åŒ–ï¼š
- **æƒ…å ±ã‚¢ã‚¯ã‚»ã‚¹ã®é«˜é€ŸåŒ–**: å¿…è¦ãªæƒ…å ±ã‚’ç¬æ™‚ã«å–å¾—
- **é‡è¤‡ä½œæ¥­ã®å‰Šæ¸›**: åŒã˜è³ªå•ã«ä½•åº¦ã‚‚ç­”ãˆã‚‹å¿…è¦ãŒãªã„
- **å“è³ªå‘ä¸Š**: ä¸€è²«ã—ãŸæƒ…å ±æä¾›ã«ã‚ˆã‚‹æ··ä¹±ã®æ¸›å°‘

å®Œç’§ã§ã¯ã‚ã‚Šã¾ã›ã‚“ãŒã€é©åˆ‡ãªè¨­å®šã¨ç¶™ç¶šçš„ãªæ”¹å–„ã«ã‚ˆã‚Šã€**ãƒãƒ¼ãƒ å…¨ä½“ã®ç”Ÿç”£æ€§å¤§å¹…å‘ä¸Š**ã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ã€‚

ã‚‚ã—Slackã§ã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹ç‡ã«æ‚©ã‚“ã§ã„ã‚‹æ–¹ãŒã„ã‚Œã°ã€ãœã²è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚æœ€åˆã¯è¨­å®šãŒå¤§å¤‰ã§ã™ãŒã€ä¸€åº¦å‹•ãå§‹ã‚ã‚‹ã¨æ‰‹æ”¾ã›ãªããªã‚Šã¾ã™ã‚ˆï¼

**çš†ã•ã‚“ã®ãƒãƒ¼ãƒ ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ”¹å–„ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã‚„è³ªå•ãŒã‚ã‚Œã°ã€ã‚³ãƒ¡ãƒ³ãƒˆã§æ•™ãˆã¦ãã ã•ã„ï¼ä¸€ç·’ã«ã‚ˆã‚Šè‰¯ã„ãƒãƒ¼ãƒ ç’°å¢ƒã‚’ä½œã£ã¦ã„ãã¾ã—ã‚‡ã†ğŸ¤–âœ¨**